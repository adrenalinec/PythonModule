# from matplotlib import *from math import *from pylab import *# from numpy import *# from spicy import *class Math(object):    passclass ChangeUnit(object):    passclass Chem(object):    passdef CtoK(Celsius):    return Celsius + 273.15def KtoC(Kelvin):    return Kelvin - 273.15class Quadratic(Math):    """    __author__:     Charles Z    __date__:       16/04/2022    __function__:   import 3 paras to calculate the root!    __method__:     solver/plot    """    def __init__(self, a: float, b: float, c: float) -> None:        self._a = a        self._b = b        self._c = c        self._delta = b ** 2 - 4 * a * c        self._AOS = b / (-2 * a)        self._extrema = -self._delta / (4 * a)    def __repr__(self):        return f'you already get a Quadratic function: {self._a}x^2 + {self._b}x + {self._c}\n' \               f'And the roots are {self.solver()}\n' \               f'{self.plot()}'    def __str__(self):        return f'you already get a Quadratic function: {self._a}x^2 + {self._b}x + {self._c}'    def solver(self):        if self._delta < 0:            print('No Real Root!')        else:            Ans1 = (-self._b + sqrt(self._delta)) / (2 * self._a)            Ans2 = (-self._b - sqrt(self._delta)) / (2 * self._a)            return round(Ans1, 5), round(Ans2, 5)    def plot(self):        A1 = arange(self._AOS - 10, self._AOS + 10, 0.1)        plot(A1, self._a * A1 ** 2 + self._b * A1 + self._c)        grid(True)        show()class Thermodynamic(Chem):    def __init__(self, delta_H=None, delta_G=None, delta_S=None,                 K1=None, K2=None, P1=None, P2=None, BP1=None, BP2=None,                 T1=None, T2=None):        """        __author__:     Charles Z        __date__:       21/04/2022        __function__:   Thermodynamic Question Solver        __method__:        :param delta_H: kJ        :param delta_G: kJ        :param delta_S: J/mol/K        :param K1:      no unit        :param K2:      no unit        :param P1:      kPa        :param P2:      kPa        :param BP1:     Celsius        :param BP2:     Celsius        :param T1:      K        :param T2:      K        """        self._parameter = {'delta_H': delta_H, 'delta_G': delta_G, 'delta_S': delta_S,                           'K1': K1, 'K2': K2, 'P1': P1, 'P2': P2, 'BP1': BP1, 'BP2': BP2,                           'T1': T1, 'T2': T2}        self._delta_H = delta_H        self._delta_G = delta_G        self._delta_S = delta_S        self._K1 = K1        self._K2 = K2        self._P1 = P1  # Pa        self._P2 = P2  # Pa        self._BP1 = BP1  # Celsius        self._BP2 = BP2  # Celsius        self._T1 = T1  # Kelvin        self._T2 = T2  # Kelvin        self._R = 8.314        self._standardCondition = (298.15, 101325)        self._kelvin = 273.15        self._avogadro = 6.0221408 * 10 ** 23        self._validParameter = self        self._law = ['firstLaw', 'secondLaw', 'thirdLaw', 'HessLaw']    # only variable name output    def __repr__(self):        inputList = []        for i in self._parameter:            if self._parameter[i] is not None:                inputList.append(i)        return f'{inputList}'    # use print can output    def __str__(self):        inputList = []        for i in self._parameter:            if self._parameter[i] is not None:                inputList.append(i)        return f'Congratulation! You already make a thermodynamic module\n' \               f'You input these parameter:{inputList}'    def BP_change_P(self):        self._BP2 = 1 / (                self._R * (math.log(self._P1 / self._P2)) / (self._delta_H * 1000) + 1 / (self._BP1 + self._kelvin))        print(round(self._BP2 - self._kelvin, 5), 'Celsius,', round(self._BP2, 5), 'Kelvin')        return round(self._BP2, 5)    def K_change_T(self):        self._K2 = self._K1 * exp(self._delta_H * 1000 / self._R * (1 / self._T1 - 1 / self._T2))        print('Changed K is ', round(self._K2, 5))    @staticmethod    def firstLaw():        return f'Energy can neither be created nor be destroyed, it can only be  transferred from ' \               f'one to another. '    @staticmethod    def secondLaw():        return f'\nThe entropy of any isolated system always increases.'    @staticmethod    def thirdLaw():        return f'The entropy of a system approaches a constant value as the temperature approaches' \               f'absolute zero.'    # @property    @staticmethod    def HessLaw():        return f'\nregardless of multiple stages or steps of a reaction, the total enthalpy change for the reaction' \               f'is the sum of all changes. This law is a manifestation that enthalpy is a state function'    def Cal_G(self):        pass    def Cal_K(self):        pass# a = thermodynamic(K1 = 33)# b = thermodynamic(delta_H = 40.8,BP1=100,P1=101,P2=101*0.33).BP_delta_P()# c = thermodynamic(delta_H=-92,T1 = 500,T2 = 800, K1 = 90)# d = thermodynamic(delta_H = 28.7,BP1=24.1,P1=53.3,P2=70).BP_delta_P()# e = Quadratic(1,2,1)# print(e.plot)# print(e)# print(c)# print(c._validParameter)# print(Thermodynamic.HessLaw())